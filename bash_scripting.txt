====================================================
ğŸ“˜ BASH SCRIPTING â€” MY DEVOPS JOURNEY NOTES
(Told like a story, with code after every lesson)
====================================================

Today I didnâ€™t just learn Bash.
I learned how DevOps engineers think.

This file is me talking to my future self.


------------------------------------
ğŸ”¹ 1. Why Bash Scripting Exists
------------------------------------
At first, I was running commands one by one.
Checking logs, filtering errors, counting issues â€” again and again.

Thatâ€™s when it clicked:
ğŸ‘‰ Bash scripting exists to save engineers from boring, repetitive work.

If something is repetitive,
it should be automated.
Thatâ€™s the DevOps mindset.


------------------------------------
ğŸ”¹ 2. Bash Is More Than Commands
------------------------------------
Bash is a full programming language.
A bash script is just a text file with commands.

Example:
Create a script file.

CODE:
touch analyze_logs.sh


------------------------------------
ğŸ”¹ 3. Making Script Executable
------------------------------------
A script wonâ€™t run unless it has execute permission.

CODE:
chmod +x analyze_logs.sh

Run it:
./analyze_logs.sh


------------------------------------
ğŸ”¹ 4. Shebang (Very Important)
------------------------------------
The system needs to know which interpreter to use.

The shebang goes on the FIRST line.

CODE:
#!/bin/bash


------------------------------------
ğŸ”¹ 5. Avoid Hardcoding (Why Variables Matter)
------------------------------------
Hardcoded paths break scripts.
Variables make scripts reusable.

CODE:
log_dir="/Users/nana/logs"


------------------------------------
ğŸ”¹ 6. Variables (Backbone of Scripts)
------------------------------------
Variables store paths, filenames, outputs, thresholds.

Rule:
â— No spaces around `=`

CODE:
app_log="application.log"
system_log="system.log"


------------------------------------
ğŸ”¹ 7. Arrays (Multiple Values in One Variable)
------------------------------------
When one value isnâ€™t enough, use arrays.

CODE:
error_patterns=(error fatal critical)


------------------------------------
ğŸ”¹ 8. Accessing Array Values
------------------------------------
Arrays are accessed using index numbers.

CODE:
echo "${error_patterns[0]}"   # error
echo "${error_patterns[1]}"   # fatal


------------------------------------
ğŸ”¹ 9. Command Substitution (Big Power Move)
------------------------------------
Capture command output into a variable.

CODE:
log_files=$(find "$log_dir" -name "*.log" -mtime -1)


------------------------------------
ğŸ”¹ 10. Looping Over Files
------------------------------------
Instead of hardcoding filenames,
loop over whatever the system finds.

CODE:
for log_file in $log_files
do
  echo "Processing $log_file"
done


------------------------------------
ğŸ”¹ 11. Looping Over Error Patterns
------------------------------------
Apply the same logic to multiple patterns.

CODE:
for pattern in "${error_patterns[@]}"
do
  echo "Searching for $pattern"
done


------------------------------------
ğŸ”¹ 12. Nested Loops (Real Automation)
------------------------------------
Loop through files,
inside that loop through patterns.

CODE:
for log_file in $log_files
do
  for pattern in "${error_patterns[@]}"
  do
    grep "$pattern" "$log_file"
  done
done


------------------------------------
ğŸ”¹ 13. Grep for Log Analysis
------------------------------------
Search logs for patterns.

CODE:
grep "error" application.log


------------------------------------
ğŸ”¹ 14. Counting Errors
------------------------------------
Count how many times a pattern appears.

CODE:
grep -c "error" application.log


------------------------------------
ğŸ”¹ 15. Saving Command Output
------------------------------------
Save grep result into a variable.

CODE:
error_count=$(grep -c "$pattern" "$log_file")


------------------------------------
ğŸ”¹ 16. Making Output Readable
------------------------------------
Scripts should talk to humans.

CODE:
echo "===== Analyzing $log_file ====="


------------------------------------
ğŸ”¹ 17. Redirecting Output to a File
------------------------------------
Save results for later review.

Overwrite file:
CODE:
echo "Log Analysis" > report.txt

Append to file:
CODE:
echo "More results" >> report.txt


------------------------------------
ğŸ”¹ 18. Writing Full Report
------------------------------------
Redirect command output into report file.

CODE:
grep "$pattern" "$log_file" >> "$report_file"


------------------------------------
ğŸ”¹ 19. Conditionals (Script That Thinks)
------------------------------------
Scripts should make decisions.

CODE:
if [ "$error_count" -gt 10 ]; then
  echo "âš ï¸ Action Required"
fi


------------------------------------
ğŸ”¹ 20. Threshold-Based Alerts
------------------------------------
Alert only when something is serious.

CODE:
if [ "$error_count" -gt 10 ]; then
  echo "Too many $pattern errors in $log_file"
fi


------------------------------------
ğŸ”¹ 21. Final Status Message
------------------------------------
Always tell the user what happened.

CODE:
echo "Log analysis completed. Report saved."


------------------------------------
ğŸ”¹ 22. Why This Matters in DevOps
------------------------------------
This single script:
âœ” saves time
âœ” avoids human error
âœ” scales easily
âœ” documents the process

This is â€œEverything as Codeâ€.


====================================================
â­ FINAL TAKEAWAY
====================================================

Bash scripting is not about memorizing syntax.

Itâ€™s about:
- removing repetition
- building systems
- thinking in automation

Today I didnâ€™t just write a script.
I learned how DevOps engineers
turn effort into efficiency.

This is day 1.
====================================================
